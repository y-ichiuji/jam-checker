# Jam Checker - コード生成指示

このドキュメントは、Jam Checkerアプリケーションの開発におけるコード生成に関するGitHub Copilotへの具体的な指示を含みます。

## コード生成の基本方針

### コンポーネント実装

#### Presentational/Containerパターン

Presentational/Containerパターンに基づいたコンポーネント実装を行う。

```typescript
// Presentationalコンポーネントの例
@Component({
  selector: 'app-traffic-display',
  standalone: true,
  imports: [CommonModule],
  template: `
    <div class="traffic-display">
      <div class="traffic-display__header">
        <h2>{{ title() }}</h2>
      </div>
      <div class="traffic-display__content">
        <!-- 混雑度を視覚的に表示 -->
        <div
          class="traffic-display__level"
          [style.background-color]="getColorForLevel(trafficLevel())"
        >
          {{ trafficLevel() }}/10
        </div>
      </div>
      <div class="traffic-display__actions">
        <button class="button" (click)="onRefresh.emit()">更新</button>
      </div>
    </div>
  `,
  styleUrls: ['./traffic-display.component.scss']
})
export class TrafficDisplayComponent {
  title = input<string>('交通情報');
  trafficLevel = input<number>(0);

  onRefresh = output<void>();

  getColorForLevel(level: number): string {
    if (level >= 8) return '#ff0000'; // 赤 - 非常に混雑
    if (level >= 5) return '#ff9900'; // オレンジ - 混雑
    if (level >= 3) return '#ffff00'; // 黄色 - やや混雑
    return '#00cc00'; // 緑 - スムーズ
  }
}

// Containerコンポーネントの例
@Component({
  selector: 'app-traffic-container',
  standalone: true,
  imports: [CommonModule, TrafficDisplayComponent],
  template: `
    <app-traffic-display
      [title]="'現在の交通状況'"
      [trafficLevel]="trafficData()?.level || 0"
      (onRefresh)="refreshData()"
    ></app-traffic-display>
  `
})
export class TrafficContainerComponent implements OnInit {
  // Signalを使用して状態を管理
  trafficData = signal<ITrafficData | null>(null);

  constructor(private trafficService: TrafficDataService) {}

  ngOnInit(): void {
    this.loadTrafficData();
  }

  loadTrafficData(): void {
    // サービスからのデータを取得し、シグナルを更新
    this.trafficService.getCurrentTrafficData().then(data => {
      this.trafficData.set(data);
    });
  }

  refreshData(): void {
    this.loadTrafficData();
  }
}
```

### マップコンポーネント実装

マップ表示には適切なマップAPIを使用し、時間帯によって交通量を視覚化する。

```typescript
// マップ表示Presentationalコンポーネント
@Component({
  selector: 'app-traffic-map-view',
  standalone: true,
  imports: [CommonModule],
  template: `
    <div class="map-container">
      <div #mapElement class="map-element"></div>
      <div class="controls">
        <div class="time-selector">
          <span>時間帯: {{ selectedTime() }}</span>
          <input type="range" [min]="0" [max]="23" [value]="timeToSliderValue(selectedTime())" (input)="onTimeChange.emit($event.target.value)">
        </div>
        <div class="legend">
          <div class="legend-item">
            <span class="color-box" style="background-color: #00cc00;"></span>
            <span>空き (0-2)</span>
          </div>
          <div class="legend-item">
            <span class="color-box" style="background-color: #ffff00;"></span>
            <span>やや混雑 (3-4)</span>
          </div>
          <div class="legend-item">
            <span class="color-box" style="background-color: #ff9900;"></span>
            <span>混雑 (5-7)</span>
          </div>
          <div class="legend-item">
            <span class="color-box" style="background-color: #ff0000;"></span>
            <span>非常に混雑 (8-10)</span>
          </div>
        </div>
      </div>
    </div>
  `,
  styleUrls: ['./traffic-map-view.component.scss']
})
export class TrafficMapViewComponent implements AfterViewInit {
  @ViewChild('mapElement') mapElement!: ElementRef;

  trafficData = input<ITrafficData[]>([]);
  selectedTime = input<string>('12:00');

  onTimeChange = output<string>();

  private map: any; // 地図APIのインスタンス

  ngAfterViewInit(): void {
    this.initializeMap();
  }

  private initializeMap(): void {
    // 地図の初期化処理
    // 例: Google Maps, Leafletなどの初期化
  }

  timeToSliderValue(time: string): number {
    const hour = parseInt(time.split(':')[0]);
    return hour;
  }
}

// マップContainerコンポーネント
@Component({
  selector: 'app-traffic-map',
  standalone: true,
  imports: [CommonModule, TrafficMapViewComponent],
  template: `
    <app-traffic-map-view
      [trafficData]="trafficData()"
      [selectedTime]="selectedTime()"
      (onTimeChange)="updateTime($event)"
    ></app-traffic-map-view>
  `
})
export class TrafficMapComponent implements OnInit {
  // Signalを使用して状態を管理
  trafficData = signal<ITrafficData[]>([]);
  selectedTime = signal<string>('12:00');

  constructor(private trafficService: TrafficDataService) {}

  ngOnInit(): void {
    this.loadTrafficData();

    // selectedTimeが変更されたときに自動的にデータを再読み込み
    effect(() => {
      // この中でselectedTime()を呼び出すことで依存関係を作成
      const time = this.selectedTime();
      this.loadTrafficData();
    });
  }

  loadTrafficData(): void {
    // サービスからのデータを取得し、シグナルを更新
    this.trafficService.getTrafficDataByTime(this.selectedTime()).then(data => {
      this.trafficData.set(data);
    });
  }

  updateTime(hourValue: string): void {
    const hour = parseInt(hourValue);
    this.selectedTime.set(`${hour.toString().padStart(2, '0')}:00`);
    // effectにより自動的にloadTrafficData()が呼ばれる
  }
}
```

### データモデル

以下のようなインターフェースを使用してデータモデルを定義する。

```typescript
export interface ITrafficData {
  id: string;
  location: {
    lat: number;
    lng: number;
  };
  level: number; // 0-10の混雑度
  timestamp: string;
  roadName?: string;
}

export interface ITimeTrafficData {
  time: string; // 'HH:MM' 形式
  areas: IAreaTrafficData[];
}

export interface IAreaTrafficData {
  areaName: string;
  center: {
    lat: number;
    lng: number;
  };
  level: number;
  details?: string;
}
```

### サービス実装

```typescript
@Injectable({
  providedIn: 'root'
})
export class TrafficDataService {
  private apiUrl = 'assets/mock-data/traffic.json'; // 初期の開発では静的データを使用

  constructor(private http: HttpClient) {}

  // Signal APIを使用したサービスメソッド
  async getCurrentTrafficData(): Promise<ITrafficData | null> {
    // 現在時刻のデータを取得
    const now = new Date();
    const hours = now.getHours().toString().padStart(2, '0');
    const timeString = `${hours}:00`;

    const data = await this.getTrafficDataByTime(timeString);
    return data[0] || null;
  }

  async getTrafficDataByTime(time: string): Promise<ITrafficData[]> {
    try {
      // 指定時間のデータを取得
      const allData = await firstValueFrom(this.http.get<ITimeTrafficData[]>(this.apiUrl));

      const timeData = allData.find(data => data.time === time);
      if (!timeData) return [];

      // エリアデータをITrafficData形式に変換
      return timeData.areas.map(area => ({
        id: `${area.areaName}-${time}`,
        location: area.center,
        level: area.level,
        timestamp: new Date().toISOString(),
        roadName: area.areaName
      }));
    } catch (error) {
      console.error('Error fetching traffic data:', error);
      return [];
    }
  }

  async getAllTimeData(): Promise<ITimeTrafficData[]> {
    try {
      return await firstValueFrom(this.http.get<ITimeTrafficData[]>(this.apiUrl));
    } catch (error) {
      console.error('Error fetching all time data:', error);
      return [];
    }
  }

  // 以下はSignalをインジェクト可能な形で提供する方法（代替アプローチ）
  // readonlyのシグナルとして、コンポーネントに公開
  readonly trafficDataSignal = toSignal(
    this.http.get<ITimeTrafficData[]>(this.apiUrl).pipe(
      catchError(error => {
        console.error('Error fetching traffic data:', error);
        return of([]);
      })
    ),
    { initialValue: [] as ITimeTrafficData[] }
  );
}
```

## スタイリング

BEM方式を採用し、以下のようなSCSSコードを生成する。

```scss
// 基本変数
$color-primary: #003366;
$color-secondary: #ff6600;
$color-background: #f5f5f5;
$color-text: #333333;
$color-light: #ffffff;
$color-border: #dddddd;

// コンポーネント例
.traffic-display {
  border-radius: 8px;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
  background-color: $color-light;
  padding: 16px;
  margin-bottom: 20px;

  &__header {
    border-bottom: 1px solid $color-border;
    padding-bottom: 8px;
    margin-bottom: 16px;

    h2 {
      color: $color-primary;
      font-size: 1.5rem;
      margin: 0;
    }
  }

  &__content {
    display: flex;
    justify-content: center;
    padding: 16px 0;
  }

  &__level {
    padding: 12px 20px;
    border-radius: 4px;
    font-weight: bold;
    color: $color-light;
    text-shadow: 0 1px 1px rgba(0, 0, 0, 0.3);
  }

  &__actions {
    display: flex;
    justify-content: flex-end;
    margin-top: 16px;

    .button {
      background-color: $color-secondary;
      color: $color-light;
      border: none;
      border-radius: 4px;
      padding: 8px 16px;
      cursor: pointer;
      transition: background-color 0.2s;

      &:hover {
        background-color: darken($color-secondary, 10%);
      }
    }
  }
}

// マップコンポーネント用
.map-container {
  position: relative;
  height: 500px;
  border-radius: 8px;
  overflow: hidden;
  box-shadow: 0 2px 6px rgba(0, 0, 0, 0.15);

  .map-element {
    width: 100%;
    height: 100%;
  }

  .controls {
    position: absolute;
    bottom: 20px;
    left: 20px;
    background: rgba(255, 255, 255, 0.9);
    padding: 12px;
    border-radius: 4px;
    box-shadow: 0 1px 4px rgba(0, 0, 0, 0.2);

    .time-selector {
      margin-bottom: 12px;

      input {
        width: 100%;
        margin-top: 8px;
      }
    }

    .legend {
      display: flex;
      flex-direction: column;
      gap: 8px;

      .legend-item {
        display: flex;
        align-items: center;

        .color-box {
          width: 16px;
          height: 16px;
          margin-right: 8px;
          border-radius: 2px;
        }
      }
    }
  }
}

// レスポンシブ対応
@media (max-width: 768px) {
  .map-container {
    height: 350px;

    .controls {
      left: 10px;
      bottom: 10px;
      padding: 8px;
      font-size: 0.9rem;
    }
  }
}
```

## テスト実装

テストはJasmine/Karmaを使用し、以下のようなパターンで作成する。

```typescript
// プレゼンテーショナルコンポーネントのテスト例
describe('TrafficDisplayComponent', () => {
  let component: TrafficDisplayComponent;
  let fixture: ComponentFixture<TrafficDisplayComponent>;

  beforeEach(async () => {
    await TestBed.configureTestingModule({
      imports: [TrafficDisplayComponent]
    }).compileComponents();

    fixture = TestBed.createComponent(TrafficDisplayComponent);
    component = fixture.componentInstance;
    fixture.detectChanges();
  });

  it('should create', () => {
    expect(component).toBeTruthy();
  });

  it('should display the correct title', () => {
    const title = '渋滞情報';
    component.title.set(title);
    fixture.detectChanges();

    const element = fixture.nativeElement;
    const titleElement = element.querySelector('.traffic-display__header h2');

    expect(titleElement.textContent).toBe(title);
  });

  it('should emit refresh event when button is clicked', () => {
    spyOn(component.onRefresh, 'emit');

    const button = fixture.nativeElement.querySelector('button');
    button.click();

    expect(component.onRefresh.emit).toHaveBeenCalled();
  });

  it('should return correct color based on traffic level', () => {
    expect(component.getColorForLevel(9)).toBe('#ff0000');
    expect(component.getColorForLevel(6)).toBe('#ff9900');
    expect(component.getColorForLevel(4)).toBe('#ffff00');
    expect(component.getColorForLevel(2)).toBe('#00cc00');
  });
});

// サービスのテスト例
describe('TrafficDataService', () => {
  let service: TrafficDataService;
  let httpTestingController: HttpTestingController;

  beforeEach(() => {
    TestBed.configureTestingModule({
      imports: [HttpClientTestingModule],
      providers: [TrafficDataService]
    });

    service = TestBed.inject(TrafficDataService);
    httpTestingController = TestBed.inject(HttpTestingController);
  });

  afterEach(() => {
    httpTestingController.verify();
  });

  it('should be created', () => {
    expect(service).toBeTruthy();
  });

  it('should return traffic data for a specific time', async () => {
    const mockData: ITimeTrafficData[] = [
      {
        time: '12:00',
        areas: [
          {
            areaName: 'エリアA',
            center: { lat: 35.681, lng: 139.767 },
            level: 5
          }
        ]
      }
    ];

    // 非同期テスト用のPromise
    const dataPromise = service.getTrafficDataByTime('12:00');

    // HTTPリクエストの処理
    const req = httpTestingController.expectOne('assets/mock-data/traffic.json');
    expect(req.request.method).toBe('GET');
    req.flush(mockData);

    // Promiseの結果を検証
    const data = await dataPromise;
    expect(data.length).toBe(1);
    expect(data[0].roadName).toBe('エリアA');
    expect(data[0].level).toBe(5);
  });

  it('should return current traffic data', async () => {
    const mockData: ITimeTrafficData[] = [
      {
        time: '12:00',
        areas: [
          {
            areaName: 'エリアA',
            center: { lat: 35.681, lng: 139.767 },
            level: 5
          }
        ]
      }
    ];

    // 現在の時間に基づいて期待される文字列を取得
    const now = new Date();
    const hours = now.getHours().toString().padStart(2, '0');
    const expectedTime = `${hours}:00`;

    // スパイを設定してgetTrafficDataByTimeメソッドのモックを作成
    spyOn(service, 'getTrafficDataByTime').and.returnValue(Promise.resolve([
      {
        id: 'エリアA-' + expectedTime,
        location: { lat: 35.681, lng: 139.767 },
        level: 5,
        timestamp: new Date().toISOString(),
        roadName: 'エリアA'
      }
    ]));

    // getCurrentTrafficDataを呼び出し
    const result = await service.getCurrentTrafficData();

    // getTrafficDataByTimeが正しいパラメータで呼び出されたことを確認
    expect(service.getTrafficDataByTime).toHaveBeenCalledWith(expectedTime);

    // 結果を検証
    expect(result).not.toBeNull();
    expect(result?.roadName).toBe('エリアA');
    expect(result?.level).toBe(5);
  });
});

// Containerコンポーネントのテスト例
describe('TrafficContainerComponent', () => {
  let component: TrafficContainerComponent;
  let fixture: ComponentFixture<TrafficContainerComponent>;
  let mockTrafficService: jasmine.SpyObj<TrafficDataService>;

  beforeEach(async () => {
    // サービスのモック作成
    mockTrafficService = jasmine.createSpyObj('TrafficDataService', ['getCurrentTrafficData']);

    // モックの戻り値設定
    mockTrafficService.getCurrentTrafficData.and.returnValue(Promise.resolve({
      id: 'test-id',
      location: { lat: 35.681, lng: 139.767 },
      level: 5,
      timestamp: new Date().toISOString(),
      roadName: 'テスト道路'
    }));

    await TestBed.configureTestingModule({
      imports: [TrafficContainerComponent, TrafficDisplayComponent],
      providers: [
        { provide: TrafficDataService, useValue: mockTrafficService }
      ]
    }).compileComponents();

    fixture = TestBed.createComponent(TrafficContainerComponent);
    component = fixture.componentInstance;
    fixture.detectChanges();
  });

  it('should create', () => {
    expect(component).toBeTruthy();
  });

  it('should load traffic data on init', async () => {
    // OnInit後にデータがロードされる
    await fixture.whenStable();

    // サービスが呼ばれたことを確認
    expect(mockTrafficService.getCurrentTrafficData).toHaveBeenCalled();

    // 複数回fixture.detectChangesを呼ぶことでシグナルの変更を反映
    fixture.detectChanges();

    // コンポーネントのシグナルが更新されていることを確認
    expect(component.trafficData()).not.toBeNull();
    expect(component.trafficData()?.level).toBe(5);
  });

  it('should refresh data when requested', async () => {
    // リフレッシュ前のスパイのリセット
    mockTrafficService.getCurrentTrafficData.calls.reset();

    // リフレッシュメソッドの呼び出し
    component.refreshData();

    // サービスが再度呼ばれたことを確認
    expect(mockTrafficService.getCurrentTrafficData).toHaveBeenCalled();

    // 処理が完了するまで待機
    await fixture.whenStable();
    fixture.detectChanges();

    // データが更新されていることを確認
    expect(component.trafficData()).not.toBeNull();
  });
});

// マップコンポーネントのテスト例
describe('TrafficMapComponent', () => {
  let component: TrafficMapComponent;
  let fixture: ComponentFixture<TrafficMapComponent>;
  let mockTrafficService: jasmine.SpyObj<TrafficDataService>;

  beforeEach(async () => {
    // サービスのモック作成
    mockTrafficService = jasmine.createSpyObj('TrafficDataService', ['getTrafficDataByTime']);

    // モックの戻り値設定
    mockTrafficService.getTrafficDataByTime.and.returnValue(Promise.resolve([{
      id: 'test-area-12:00',
      location: { lat: 35.681, lng: 139.767 },
      level: 5,
      timestamp: new Date().toISOString(),
      roadName: 'テストエリア'
    }]));

    await TestBed.configureTestingModule({
      imports: [TrafficMapComponent, TrafficMapViewComponent],
      providers: [
        { provide: TrafficDataService, useValue: mockTrafficService }
      ]
    }).compileComponents();

    fixture = TestBed.createComponent(TrafficMapComponent);
    component = fixture.componentInstance;
    fixture.detectChanges();
  });

  it('should create', () => {
    expect(component).toBeTruthy();
  });

  it('should load traffic data for the selected time on init', async () => {
    // OnInit後にデータがロードされる
    await fixture.whenStable();

    // サービスが初期時間帯（'12:00'）で呼ばれたことを確認
    expect(mockTrafficService.getTrafficDataByTime).toHaveBeenCalledWith('12:00');

    fixture.detectChanges();

    // シグナルが更新されていることを確認
    expect(component.trafficData().length).toBe(1);
    expect(component.trafficData()[0].roadName).toBe('テストエリア');
  });

  it('should update time and reload data when time changes', async () => {
    // 時間変更前のスパイのリセット
    mockTrafficService.getTrafficDataByTime.calls.reset();

    // 新しい時間のモックレスポンス設定
    mockTrafficService.getTrafficDataByTime.and.returnValue(Promise.resolve([{
      id: 'test-area-16:00',
      location: { lat: 35.681, lng: 139.767 },
      level: 7,
      timestamp: new Date().toISOString(),
      roadName: 'テストエリア（混雑）'
    }]));

    // 時間を更新（16時に変更）
    component.updateTime('16');

    // effectのトリガーを待機
    await fixture.whenStable();

    // '16:00'で呼ばれたことを確認
    expect(mockTrafficService.getTrafficDataByTime).toHaveBeenCalledWith('16:00');

    // UIの更新を反映
    fixture.detectChanges();

    // 選択時間と交通データが更新されていることを確認
    expect(component.selectedTime()).toBe('16:00');
    expect(component.trafficData()[0].level).toBe(7);
    expect(component.trafficData()[0].roadName).toBe('テストエリア（混雑）');
  });
});
```

このドキュメントは、Jam Checkerアプリケーションのコード生成のための具体的な指示と例を提供します。上記のパターンとガイドラインに従って、コードを生成してください。
